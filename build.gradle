import org.ajoberstar.gradle.git.tasks.*

apply plugin: 'cargo'
apply plugin: 'war'
apply plugin: 'maven'


//Initialization
def artifactId = project.name
def artifactDownloadPath = "build/libs/" + artifactId + ".war"
def userName = System.getProperty("user.name")
def userPropsFile = project.file(userName + ".properties")
def gradlePropsFile = project.file("gradle.properties")
def branchName = ""

//If user properties don't exist create it based on template.
if(!userPropsFile.exists())
{
	def templateFile = file("userTemplate.properties")
	ant.copy(file:templateFile.getAbsolutePath(), toFile: userPropsFile.getAbsolutePath() )
}
def userProperties = new Properties()
def userFileReader = new FileReader(userPropsFile)
userProperties.load(userFileReader)
userFileReader.close()	

//Load user properties
for(currentUserProperty in userProperties.stringPropertyNames())
{
	project.ext.set(currentUserProperty, userProperties.getProperty(currentUserProperty))
}

//Configurations
project.ext.set('env', hasProperty('env') ? env : 'dev')

buildscript {
	repositories {
		maven { url "https://oss.sonatype.org/content/groups/public"}
		mavenCentral()
	}

	dependencies {
		classpath   "javax.servlet:servlet-api:2.5",
					"org.gradle.api.plugins:gradle-cargo-plugin:0.6.1",
					"org.ajoberstar:gradle-git:0.6.3"
	}
}

cargo {
	containerId = 'tomcat7x'
	port = Integer.parseInt(getProperty(project.env + ".deployPort"))

	deployable {
		context = artifactId
		file = project.file(artifactDownloadPath)
	}
	
	remote {
		hostname = getProperty(project.env + ".deployHostname")
		username = getProperty(project.env + ".deployUserName")
		password = getProperty(project.env + ".deployPassword")
	}
	
}

repositories {
	
	mavenCentral()
	maven{ url "$repositoryContextUrl/libs-releases" }
	
}

dependencies {
	def cargoVersion = '1.3.3'
	def springVersion = '3.2.3.RELEASE'
	def wro4JVersion = '1.6.3'
	def aopAllainceVersion = '1.0'
	cargo "org.codehaus.cargo:cargo-core-uberjar:$cargoVersion", "org.codehaus.cargo:cargo-ant:$cargoVersion"
	compile "org.springframework:spring-aop:$springVersion", "org.springframework:spring-beans:$springVersion", 
	"org.springframework:spring-context:$springVersion","org.springframework:spring-context-support:$springVersion",
	"org.springframework:spring-expression:$springVersion", "org.springframework:spring-tx:$springVersion",
	"org.springframework:spring-web:$springVersion", "org.springframework:spring-webmvc:$springVersion", "org.mongodb:mongo-java-driver:2.9.1",
	"javax.servlet:jstl:1.2","org.slf4j:slf4j-api:1.5.6", "org.slf4j:jcl-over-slf4j:1.5.6", "org.slf4j:slf4j-log4j12:1.5.6", "log4j:log4j:1.2.16",
	"org.codehaus.jackson:jackson-mapper-asl:1.9.3","aopalliance:aopalliance:$aopAllainceVersion","log4j:log4j:1.2.9"
	compile("org.springframework.data:spring-data-mongodb:1.0.4.RELEASE"){
		exclude module: "slf4j-api"
	}
	compile("org.springframework:spring-core:$springVersion"){
		exclude module: 'commons-logging'
	}
	compile ("ro.isdc.wro4j:wro4j-core:$wro4JVersion")
	{
		exclude module: "slf4j-api"
	}
  
	compile("ro.isdc.wro4j:wro4j-extensions:$wro4JVersion")
	{
		exclude module: "slf4j-api"
		exclude module: "slf4j-log4j12"
	}
	providedCompile "javax.el:el-api:1.0", "javax.servlet.jsp:jsp-api:2.0", "javax.servlet:servlet-api:2.5"
	testCompile "junit:junit:4.11", "org.springframework:spring-test:$springVersion"

}

uploadArchives {
	repositories {
		mavenDeployer {
			pom.artifactId = artifactId
			repository(url: "$repositoryContextUrl/libs-release-local" ){
				authentication(userName: "$repositoryUser", password: "$repositoryPassword")
			}
			
		}
	}
}

task downloadWar(dependsOn: 'getBranchName') << {
	
	def groupPath = project.group.replace(".", "/")
	def defaultVersion = project.version + ".$branchName"
	
	def versionPath = promptForVersion("Enter Version: [$defaultVersion]", defaultVersion)
	
	def artifactNamePath = artifactId + "-" + versionPath + ".war"
	
	def downloadUrl = "$repositoryContextUrl/libs-release-local/$groupPath/$artifactId/$versionPath/$artifactNamePath"
	
	def targetDir = new File('build/libs')
	
	if(!targetDir.isDirectory())
	{
		targetDir.mkdirs()
	}
	
	ant.get(src: downloadUrl, dest: artifactDownloadPath)
	
}

task updateUploadedPom(dependsOn: 'getBranchName') << {
	def pomVersion = project.version
	if(!project.getGradle().getTaskGraph().hasTask(":release"))
		pomVersion += ".$branchName"
	uploadArchives.repositories.mavenDeployer.pom.version = pomVersion
}

task updateVersionNumber << {
	def oldVersion = "${project.version}"
	
	
	//Increment Version Number
	def oldVersionArray = oldVersion.split("\\.")
	def majorVersion = oldVersionArray[0]
	def minorVersion = oldVersionArray[1]
	def patchVersion = Integer.parseInt(oldVersionArray[2]) + 1
	def defaultVersion =  "$majorVersion.$minorVersion.$patchVersion"
	
	def versionPath = promptForVersion("Enter Version: [$defaultVersion]", defaultVersion)
	
	try {
		project.ant.replace(file: gradlePropsFile, token: "version=${oldVersion}", value: "version=${versionPath}", failOnNoReplacements: true)
	} catch (org.apache.tools.ant.BuildException be) {
		throw new GradleException("Unable to update version property.")
	}
	
}

task getBranchName(type: GitBranchList) << {
	branchName = getWorkingBranch().name
	print branchName
}

task tag(type: GitTag) {
	tagName = version
	message = "Release of ${version}"
}

task pushToRemote(type: GitPush){
	pushAll = true
}

task addVersionUpdate(type: GitAdd){
	includes = ['application.properties', 'gradle.properties']
}

task commitVersionUpdate(type: GitCommit) {
	message = "Version Number ${version}"
}

task qaRelease {
	dependsOn test, war, getBranchName, updateUploadedPom, uploadArchives, updateVersionNumber, addVersionUpdate, commitVersionUpdate, pushToRemote
}

task release {
	dependsOn test, war, tag, updateUploadedPom, uploadArchives, updateVersionNumber, addVersionUpdate, commitVersionUpdate, pushToRemote
}

//Task Dependencies
war.mustRunAfter test
tag.mustRunAfter war
updateUploadedPom.mustRunAfter tag
uploadArchives.mustRunAfter updateUploadedPom
updateVersionNumber.mustRunAfter uploadArchives
addVersionUpdate.mustRunAfter updateVersionNumber
commitVersionUpdate.mustRunAfter addVersionUpdate
pushToRemote.mustRunAfter commitVersionUpdate

//Helper functions
def promptForVersion(versionMessage, defaultVersion){
	if(System.console())
	{
		return System.console().readLine(versionMessage) ?: defaultVersion
	}
	else
	{
		println versionMessage
		return System.in.newReader().readLine() ?: defaultVersion
	}
}